# Port and Domain Configuration Guide

Complete guide to understanding and configuring XaresAICoder's port and domain settings for different deployment scenarios.

## Table of Contents

- [Configuration Variables](#configuration-variables)
- [Deployment Scenarios](#deployment-scenarios)
- [Architecture Diagrams](#architecture-diagrams)
- [Common Misconfigurations](#common-misconfigurations)
- [Troubleshooting](#troubleshooting)

## Configuration Variables

XaresAICoder uses four key variables to handle ports and domains across different deployment architectures:

### `HOST_PORT` 
- **Purpose**: Port that Docker exposes on the host machine for nginx access
- **Default**: `80`
- **Used by**: Docker Compose port mapping (`docker-compose.yml`)
- **Format**: `${HOST_PORT}:80` maps host port to nginx container port 80

### `BASE_PORT`
- **Purpose**: Port used for URL generation logic and internal nginx listen configuration
- **Default**: `80`
- **Used by**: 
  - Workspace URL generation (determines if `:port` is included)
  - nginx template (`listen ${BASE_PORT}`)
  - Container environment variables
- **Logic**: If `BASE_PORT !== '80'`, port number is included in URLs

### `BASE_DOMAIN`
- **Purpose**: Domain name used in workspace URLs and routing
- **Default**: `localhost`
- **Used by**: URL generation for workspace subdomains
- **Examples**: `localhost`, `dev.company.internal`, `coder.example.com`

### `PROTOCOL`
- **Purpose**: Protocol scheme for generated URLs (http/https)
- **Default**: `http`
- **Used by**: URL generation and container configuration
- **Values**: `http` or `https`

## Deployment Scenarios

### Scenario 1: Local Development

**Use Case**: Developer laptop, testing, development

**Configuration**:
```bash
HOST_PORT=80
BASE_PORT=80
BASE_DOMAIN=localhost  
PROTOCOL=http
```

**Architecture**:
```
Browser → localhost:80 → XaresAICoder nginx → Express API (port 3000)
```

**Generated URLs**:
- Main application: `http://localhost/`
- Workspace: `http://workspace-id.localhost/`
- Port forwarding: `http://workspace-id-5000.localhost/`

**Why this works**: 
- `BASE_PORT=80` ensures no `:80` in URLs (clean URLs)
- `HOST_PORT=80` makes it accessible on standard HTTP port
- Everything runs locally without external dependencies

---

### Scenario 2: Internal Server (Direct Access)

**Use Case**: Internal company server, development team access, no SSL proxy

**Configuration**:
```bash
HOST_PORT=8000
BASE_PORT=8000
BASE_DOMAIN=dev.company.internal
PROTOCOL=http
```

**Architecture**:
```
Browser → dev.company.internal:8000 → XaresAICoder nginx → Express API
```

**Generated URLs**:
- Main application: `http://dev.company.internal:8000/`
- Workspace: `http://workspace-id.dev.company.internal:8000/`
- Port forwarding: `http://workspace-id-5000.dev.company.internal:8000/`

**Why this works**:
- `BASE_PORT=8000` includes `:8000` in all URLs (needed for direct access)
- `HOST_PORT=8000` exposes the service on port 8000
- Port numbers are visible to users but functional

---

### Scenario 3: Internet Server (External SSL Proxy)

**Use Case**: Production deployment with external nginx handling SSL termination

**Configuration**:
```bash
HOST_PORT=7200          # Port external nginx proxies to
BASE_PORT=80            # Creates clean URLs without port numbers
BASE_DOMAIN=coder.example.com
PROTOCOL=http           # Internal traffic is HTTP
```

**Architecture**:
```
Internet → External nginx (SSL) → localhost:7200 → XaresAICoder nginx → Express API
         HTTPS                      HTTP              HTTP
```

**Traffic Flow**:
1. XaresAICoder generates: `http://workspace-id.coder.example.com/`
2. User clicks link → External nginx receives HTTP request
3. External nginx **redirects**: `HTTP → HTTPS` (301/302 redirect)
4. Browser makes new request: `https://workspace-id.coder.example.com/`
5. External nginx **proxies**: `HTTPS → HTTP` (to localhost:7200)

**Generated URLs**:
- Generated by XaresAICoder: `http://workspace-id.coder.example.com/`
- Actually used by users: `https://workspace-id.coder.example.com/`

**Why this works**:
- `BASE_PORT=80` generates clean URLs without `:80`
- External nginx handles SSL termination and HTTPS redirect
- `HOST_PORT=7200` avoids conflicts with external nginx (which uses :80/:443)
- Internal communication remains HTTP for simplicity

## Architecture Diagrams

### Scenario 1: Local Development
```
┌─────────────┐    :80     ┌─────────────────┐    :3000   ┌─────────────┐
│   Browser   │ ---------> │ XaresAICoder    │ ---------> │ Express API │
│             │            │ nginx           │            │ Server      │
└─────────────┘            └─────────────────┘            └─────────────┘
                                   │
                                   │ docker network
                                   ▼
                           ┌─────────────────┐
                           │ Workspace       │
                           │ Containers      │
                           └─────────────────┘
```

### Scenario 2: Internal Server
```
┌─────────────┐   :8000    ┌─────────────────┐    :3000   ┌─────────────┐
│   Browser   │ ---------> │ XaresAICoder    │ ---------> │ Express API │
│             │            │ nginx           │            │ Server      │
└─────────────┘            └─────────────────┘            └─────────────┘
company.internal:8000              │
                                   │ docker network  
                                   ▼
                           ┌─────────────────┐
                           │ Workspace       │
                           │ Containers      │
                           └─────────────────┘
```

### Scenario 3: External SSL Proxy
```
┌─────────────┐   :443     ┌─────────────────┐   :7200    ┌─────────────────┐    :3000  ┌─────────────┐
│   Browser   │ ---------> │ External nginx  │ ---------> │ XaresAICoder    │ --------> │ Express API │
│             │   HTTPS    │ (SSL Proxy)     │    HTTP    │ nginx           │           │ Server      │ 
└─────────────┘            └─────────────────┘            └─────────────────┘           └─────────────┘
    ▲                               │                               │
    │ HTTP→HTTPS redirect           │ SSL termination               │ docker network
    └───────────────────────────────┘                               ▼
                                                           ┌─────────────────┐
                                                           │ Workspace       │
                                                           │ Containers      │
                                                           └─────────────────┘
                                                           
```

## Common Misconfigurations

### ❌ Wrong: External SSL Proxy with PORT in URLs
```bash
# INCORRECT for external SSL proxy
BASE_PORT=7200    # ❌ Creates URLs like http://workspace-id.example.com:7200
HOST_PORT=7200
```
**Problem**: URLs include `:7200` which users can't access directly

**Solution**: Use `BASE_PORT=80` to generate clean URLs

### ❌ Wrong: Internal Server without PORT in URLs  
```bash
# INCORRECT for internal server on non-standard port
BASE_PORT=80      # ❌ Creates URLs like http://workspace-id.company.com
HOST_PORT=8000
```
**Problem**: URLs don't include `:8000`, so they're not accessible

**Solution**: Use `BASE_PORT=8000` to include port in URLs

### ❌ Wrong: HTTPS Protocol with External Proxy
```bash
# INCORRECT for external SSL proxy setup
PROTOCOL=https    # ❌ Creates https:// URLs but internal traffic is HTTP
BASE_PORT=443     # ❌ Wrong port for URL generation
```
**Problem**: XaresAICoder tries to generate HTTPS URLs internally

**Solution**: Use `PROTOCOL=http` and `BASE_PORT=80` - let external nginx handle HTTPS

## Troubleshooting

### Problem: "URLs have wrong port numbers"
**Symptom**: Workspace URLs show `:7200` or other internal ports  
**Cause**: `BASE_PORT` set to `HOST_PORT` in external proxy setup  
**Solution**: Set `BASE_PORT=80` for clean URLs in external proxy setups

### Problem: "Can't access workspaces on custom port"
**Symptom**: Workspace URLs don't include port for internal server  
**Cause**: `BASE_PORT=80` when `HOST_PORT` is non-standard port  
**Solution**: Set `BASE_PORT` to match `HOST_PORT` for direct access

### Problem: "Mixed HTTP/HTTPS issues" 
**Symptom**: Some requests fail with protocol errors  
**Cause**: `PROTOCOL=https` with external SSL proxy  
**Solution**: Use `PROTOCOL=http` - external nginx handles HTTPS upgrade

### Problem: "Port conflicts"
**Symptom**: "Port already in use" errors during deployment  
**Cause**: `HOST_PORT` conflicts with other services  
**Solution**: Change `HOST_PORT` to available port (e.g., 7200, 8000)

## Quick Reference

| Scenario |  HOST_PORT | BASE_PORT | BASE_DOMAIN | PROTOCOL |
|-------------|-----------|-----------|-------------|----------|
| **Local Dev** |  80 | 80 | localhost | http |
| **Internal Server** |  8000 | 8000 | internal.company.com | http |  
| **External SSL Proxy** |  7200 | 80 | coder.example.com | http |

## Related Documentation

- [Installation Guide](INSTALLATION.md) - General installation instructions
- [Architecture Overview](ARCHITECTURE.md) - System architecture details
- [Troubleshooting](TROUBLESHOOTING.md) - Common issues and solutions
- [Deployment Guide](../DEPLOYMENT.md) - Deployment-specific instructions